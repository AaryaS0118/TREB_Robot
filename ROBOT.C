#pragma config(Sensor, in1,    PD1,            sensorAnalog)
#pragma config(Sensor, in2,    PD2,            sensorAnalog)
#pragma config(Sensor, in3,    PD3,            sensorAnalog)
#pragma config(Sensor, in4,    PD4,            sensorAnalog)
#pragma config(Sensor, in5,    PD5,            sensorAnalog)
#pragma config(Sensor, in6,    PD6,            sensorAnalog)
#pragma config(Sensor, in7,    PD7,            sensorAnalog)

#pragma config(Sensor, dgtl3,  frontLimit,     sensorTouch)      // front limit switch
#pragma config(Sensor, dgtl5,  backRight,      sensorTouch)      // back right bumper
#pragma config(Sensor, dgtl6,  backLeft,       sensorTouch)      // back left bumper
#pragma config(Sensor, dgtl10, freqSelect,     sensorDigitalOut) // 0=red(1kHz), 1=green(10kHz)

#pragma config(Motor,  port3,  leftMotor,      tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port10, rightMotor,     tmotorVex393_HBridge, openLoop)
#pragma config(Servo,  port9,  armServo,       tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
  TREB - State Machine Rebuild (ROBOTC, VEX Cortex)

  States match your documented stages:
    FIND_RED  -> PRESS_RED -> BACKOUT -> FIND_GREEN -> SECURE_GREEN -> EXIT

  Beacon seeking uses GOTO BEACON style:
    Read_PD(), find_max(), move()

  Files confirm 7 photodetectors, freq variable (1kHz red / 10kHz green),
  and bumper-based arena exit logic. 
*/

//////////////////////
// Global parameters //
//////////////////////

typedef enum {
  FIND_RED = 0,
  PRESS_RED,
  BACKOUT_FROM_RED,
  FIND_GREEN,
  SECURE_GREEN,
  EXIT_ARENA
} State;

State state = FIND_RED;

// Beacon select: 0=red, 1=green
int freq = 0;

// Movement tuning (based on your variable lists/screenshots; tune as needed)
int ambient_level = 100;
int slow_level    = 5000;
int stop_level    = 6000;
int steer_sensitivity = 21;
int forward_speed     = 40;
int slow_speed        = 20;
int spin_speed        = 70;

// Servo mapping
int SERVO_CENTER = 127; // centered value for arm servo commands

// PD data
int pd[7];
int pd_sum = 0;
int max_idx = 3;
int max_val = 0;

// IR board assumed on analog in1..in7
tSensors pdPorts[7] = {PD1, PD2, PD3, PD4, PD5, PD6, PD7};

//////////////////////////
// Low-level primitives  //
//////////////////////////

void SetMotorPct(int leftPct, int rightPct) {
  motor[leftMotor]  = leftPct;
  motor[rightMotor] = rightPct;
}

void StopDrive() {
  SetMotorPct(0, 0);
}

void SetArmCentered(int v) {  // v is -127..127
  int out = SERVO_CENTER + v;
  if(out < 0) out = 0;
  if(out > 255) out = 255;
  servo[armServo] = out;
}

void SetBeaconFreq(int f) {
  freq = f;
  SensorValue[freqSelect] = (f != 0);
}

//////////////////////////////
// GOTO-BEACON style methods //
//////////////////////////////

void Read_PD() {
  pd_sum = 0;
  for(int i=0; i<7; i++) {
    pd[i] = SensorValue[pdPorts[i]];
    pd_sum += pd[i];
  }
}

void find_max() {
  max_val = pd[0];
  max_idx = 0;
  for(int i=1; i<7; i++) {
    if(pd[i] > max_val) {
      max_val = pd[i];
      max_idx = i;
    }
  }
}

// One control step toward beacon
void move_step() {
  if(max_val < ambient_level) {
    // search spin
    SetMotorPct(spin_speed, -spin_speed);
    return;
  }

  int base = (max_val > slow_level) ? slow_speed : forward_speed;
  int error = (max_idx - 3);
  int steer = error * steer_sensitivity;

  int leftCmd  = base + steer;
  int rightCmd = base - steer;

  if(leftCmd  > 127) leftCmd  = 127;
  if(leftCmd  < -127) leftCmd = -127;
  if(rightCmd > 127) rightCmd = 127;
  if(rightCmd < -127) rightCmd= -127;

  SetMotorPct(leftCmd, rightCmd);
}

//////////////////////////
// Higher-level actions  //
//////////////////////////

bool FrontContacted() {
  return (SensorValue[frontLimit] != 0);
}

// Try pressing red until PD sum indicates "off"
bool PressRedBeaconOff() {
  const int OFF_THRESHOLD = 400; // from your screenshot logic (pd_sum < ~400)
  int attempts = 0;

  // stiff/up start
  SetArmCentered(-40);

  while(attempts < 8) {
    // slam sequence (timing/angles tunable)
    SetArmCentered(20);   wait1Msec(1000);
    SetArmCentered(110);  wait1Msec(750);
    SetArmCentered(0);    wait1Msec(250);

    SetArmCentered(-70);  wait1Msec(1000);
    SetArmCentered(0);    wait1Msec(250);

    Read_PD();
    if(pd_sum < OFF_THRESHOLD) {
      SetArmCentered(-40); // stiff
      return true;
    }

    // micro-adjust and retry
    SetMotorPct(20, -20); wait1Msec(250);
    StopDrive();          wait1Msec(250);

    attempts++;
  }

  return false;
}

void BackOutFromRed() {
  SetMotorPct(-20, -20);
  wait1Msec(1000);
  StopDrive();
}

void SecureGreen() {
  StopDrive();
  SetArmCentered(0);   wait1Msec(250);
  SetArmCentered(50);  wait1Msec(750);
  SetArmCentered(0);   wait1Msec(250);

  // small settling
  SetMotorPct(-40, 40); wait1Msec(500);
  StopDrive();

  SetArmCentered(40); // holding angle approximation
}

// Exit by bumpers: L => CCW, R => CW, both => fast straight
void ExitArenaStep() {
  int L = SensorValue[backLeft];
  int R = SensorValue[backRight];

  if(L && R) {
    SetMotorPct(80, 80);
    wait1Msec(1000);
  }
  else if(L) {
    SetMotorPct(-20, 90);
    wait1Msec(750);
    StopDrive(); wait1Msec(500);
  }
  else if(R) {
    SetMotorPct(90, -20);
    wait1Msec(750);
    StopDrive(); wait1Msec(500);
  }
  else {
    SetMotorPct(-80, -80);
    wait1Msec(200);
  }
}

//////////////////////
// Main state engine //
//////////////////////

task main() {
  // initial arm posture
  SetArmCentered(-40);

  while(true) {
    switch(state) {

      case FIND_RED:
        SetBeaconFreq(0);         // red 1kHz
        ambient_level = 100;

        // run beacon seeking until contact
        while(!FrontContacted()) {
          Read_PD();
          find_max();
          move_step();
          wait1Msec(20);
        }
        StopDrive();
        state = PRESS_RED;
        break;

      case PRESS_RED:
        // press until off (or max attempts)
        PressRedBeaconOff();
        state = BACKOUT_FROM_RED;
        break;

      case BACKOUT_FROM_RED:
        BackOutFromRed();
        state = FIND_GREEN;
        break;

      case FIND_GREEN:
        SetBeaconFreq(1);         // green 10kHz
        ambient_level = 50;

        while(!FrontContacted()) {
          Read_PD();
          find_max();
          move_step();
          wait1Msec(20);
        }
        StopDrive();
        state = SECURE_GREEN;
        break;

      case SECURE_GREEN:
        SecureGreen();
        state = EXIT_ARENA;
        break;

      case EXIT_ARENA:
        // continue until physically out (no sensor for "out", so run indefinitely)
        ExitArenaStep();
        break;
    }
  }
}
